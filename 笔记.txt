1.assets的icon.styl还是按自己的弄，其它的可以模仿

2.做东西时要明确区分 dev 和 prod 的依赖包
    npm i --save-dev  <packname>  
        工程构建（开发时、“打包”时）依赖 ；例：xxx-cli , less-loader , babel-loader...

    npm i --save <packname> 
        项目（运行时、发布到生产环境时）依赖；例：antd,element,vue,react...

    关于如何区分 dev 和 prod 的依赖包

    例如，你写了一个 proxy的插件，依赖了 request模块，这个时候，发布以后如果
    别人使用必须同时安装 request 模块，这个就是 dependencies

    还是在开发一个模块的时候， 如果这个时候你需要搞一个工具检查你写的代码、或者
    babel转译、less转译。在使用的时候呢，根本不需要这些，它们只负责编译时调用，这
    个就是 devDependencies

3.关于组建命名的规范：
    文件夹名：文件夹名都是小写
    文件名： ( 一句话：只有主组件是大写开头 )
        通用组件放在src里的components里，文件名全小写。
        主组件放在pages里，文件名大写开头
        主组件的私有组件放在pages/xxx/components里，文件名小写
       
    export default {name} / import
        驼峰命名 例如：m-header --> MHeader
        import MHeader from ...
    
    标签全小写
        <m-header></m-header>

4.关于什么时候需要在data里定义属性的问题。
    如过该属性需要上template或者watch，那么就需要定义在data里。

5.jsonp是可以解决跨域、但解决是的同源策略的跨域。
如果后端给接口设置了host和referer，jsonp就会获取失败。
这时候就需要依靠代理了。
var app = express()
var apiRoutes = express.Router()
apiRoutes.get('/getDiscList', function (req, res) {
  var url = 'https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg'
  axios.get(url, {
    headers: {
      referer: 'https://c.y.qq.com/',
      host: 'c.y.qq.com'
    },
    params: req.query
  }).then((response) => {
    res.json(response.data)
  }).catch((e) => {
    console.log(e)
  })
})

6.slider组件的按钮有点延迟，看着不舒服。

7.better-scroll下一定要被一个整的div包裹

8.fastclick会阻止better-scroll派发的click事件。
（新版本好像没有这个问题了）如果遇到了就在要点击的地方加一个needclick class就行

9.<img src="" width="24" height="24">


10.关于配置路由
    1.定义组件，引进路由

    2.定义路由策略
      routes: [
            {
                path: '/recommend',
                name: 'Recommend',
                component: Recommend
            },
            {
                path: '/singer',
                name: 'Singer',
                component: Singer,
                children: [
                    {
                    // singer/:id
                    path: ':id',
                    component: SingerDetail
                    }
                ]
            }]

    3.确定出口 router-view
    4.在对应的组件下写路由跳转router-link/vm.$router.push，
        (注意：
            跳转必须是同级的，比如上面的，
            只能在pages级别配置跳转/singer /recommend
            而/singer/:id 只能在singer组件下配置跳转)


11.简单状态管理实现
    -创建store，并在主入口挂载进data
        var store = {
            debug: true,
            state: {
                message: 'Hello!'
            },
            setMessageAction (newValue) {
                if (this.debug) console.log('setMessageAction triggered with', newValue)
                this.state.message = newValue
            },
            clearMessageAction () {
                if (this.debug) console.log('clearMessageAction triggered')
                this.state.message = ''
            }
        }

        -main.js
        new Vue({
            data: {
                store
            }
        })
        

    -xxx.vue 组件内接收state
        export default {
            data () {
                return {
                    privateState: {},
                    sharedState: this.$root.$data.store.state
                }
            } 
        }
    
    -xxx.vue
        export default {
            data () {
                return {
                    privateState: {},
                    sharedState: this.$root.$data.store.state
                }
            } 
        }

    如果要修改状态
        this.$root.$data.store.setMessageAction(newValue)


12.关于vuex的映射
    mapMutations/mapActions 映射在methods里
    mapState/mapGetters 映射在computed里


13.页面刷新后vuex里面的数据会清空
    解决办法
        //在页面刷新时将vuex里的信息保存到sessionStorage/localstorage里

        window.addEventListener("beforeunload",()=>{
            sessionStorage.setItem("store",JSON.stringify(this.$store.state))
        })

        //在页面加载时读取sessionStorage/localstorage里的状态信息

        if (sessionStorage.getItem("store") ) {
            this.$store.replaceState(Object.assign({}, this.$store.state,JSON.parse(sessionStorage.getItem("store"))))
        }

14.对象通通大写

15.props中数组默认为空的写法
    data: {
      type: Array,
      // default: []
      default: () => []
    }

16.下次img和image要统一一下。统一写img

17.关于vuex的使用
    首先在src中创建store文件夹
    然后在main.js中注册插件
    import store from './store'
    new Vue({store})

    然后回到store文件夹下创建 
        state.js  存放公共数据
        getters.js  用于对数据的映射
        mutations.js  对数据的简单修改值操作
        mutation-types.js  定义mutations的操作名
        actions.js  批量的mutations操作或者异步操作
        index.js  下面是模版
            import Vue from 'vue'
            import Vuex from 'vuex'
            import * as actions from './actions'
            import * as getters from './getters'
            import state from './state'
            import mutations from './mutations'
            import createLogger from 'vuex/dist/logger'

            Vue.use(Vuex)

            const debug = process.env.NODE_ENV !== 'production'

            export default new Vuex.Store({
                actions,
                getters,
                state,
                mutations,
                strict: debug,
                plugins: debug ? [createLogger()] : []
            })


18.  vuex - Do not mutate vuex store state outside mutation handlers. 错误
    注意所有引用类型的state，如果传进来的值(假设为list)也是一个引用类型
  那么此时的state就绑定了list的地址
  而vuex的说明是不允许mutate以外的任何地方修改state
  这下就会报 Do not mutate vuex store state outside mutation handlers. 错误
  原因是此时的state是浅克隆，外部如果直接修改list，也就直接修改了state
  这就违背了vuex的原则
  解决办法：
       1.state.list = Object.assign([], list)
       2.state.list = JSON.parse(JSON.stringify(list))
  比较推荐方法2，方法1的话如果传进来的是数组，那么assign后是一个类数组，
  类数组没有length属性


19.歌曲封面会卡也没办法，除非设置多个源，然后设置timeout，去重新请求新源。
    timeout的思路：
    <img src="image.gif" id="img" />
    <script>
        var oImg = document.getElementById("img");
        var timer = setTimeOut(function(){
        alert("加载超时！请重试！");
        },5000);
        oImg.onload = function () {
            clearTimeOut(timer);
            timer = null;
        }
    </script>

20.对随机播放方面做了点改进，下一首的时候index取一个除了自己之外的随机数，
然后prev允许返回一次。